package io.github.bsayli.codegen.initializr.cli;

import io.github.bsayli.codegen.initializr.projectgeneration.model.Dependency;
import io.github.bsayli.codegen.initializr.projectgeneration.model.ProjectType;
import io.github.bsayli.codegen.initializr.projectgeneration.model.spring.SpringBootJavaProjectMetadata.SpringBootJavaProjectMetadataBuilder;
import io.github.bsayli.codegen.initializr.projectgeneration.model.techstack.BuildTool;
import io.github.bsayli.codegen.initializr.projectgeneration.model.techstack.Framework;
import io.github.bsayli.codegen.initializr.projectgeneration.model.techstack.Language;
import io.github.bsayli.codegen.initializr.projectgeneration.service.ProjectGenerationService;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.*;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Profile("cli")
public class CliRunner implements ApplicationRunner {

  private static final Logger log = LoggerFactory.getLogger(CliRunner.class);

  private static final String ARG_GROUP_ID = "groupId";
  private static final String ARG_ARTIFACT_ID = "artifactId";
  private static final String ARG_NAME = "name";
  private static final String ARG_PACKAGE_NAME = "packageName";
  private static final String ARG_JAVA_VERSION = "javaVersion";
  private static final String ARG_BOOT_VERSION = "springBootVersion";
  private static final String ARG_OUTPUT_DIR = "outputDir";
  private static final String ARG_OVERWRITE = "overwrite";

  private static final String DEF_GROUP_ID = "com.example";
  private static final String DEF_ARTIFACT_ID = "demo-app";
  private static final String DEF_PACKAGE_NAME = "com.example.demo";
  private static final String DEF_JAVA_VERSION = "21";
  private static final String DEF_BOOT_VERSION = "3.5.5";
  private static final String DEF_DESCRIPTION = "Generated by codegen-initializr-core";
  private static final boolean DEF_OVERWRITE = false;

  private static final Path DEFAULT_OUTPUT_ROOT =
      Paths.get(System.getProperty("user.dir"), "target", "generated-projects");

  private final ProjectGenerationService service;

  public CliRunner(ProjectGenerationService service) {
    this.service = service;
  }

  @Override
  public void run(ApplicationArguments args) throws Exception {
    String groupId = argOrDefault(args, ARG_GROUP_ID, DEF_GROUP_ID);
    String artifact = argOrDefault(args, ARG_ARTIFACT_ID, DEF_ARTIFACT_ID);
    String name = argOrDefault(args, ARG_NAME, artifact);
    String pkg = argOrDefault(args, ARG_PACKAGE_NAME, DEF_PACKAGE_NAME);
    String javaVer = argOrDefault(args, ARG_JAVA_VERSION, DEF_JAVA_VERSION);
    String bootVer = argOrDefault(args, ARG_BOOT_VERSION, DEF_BOOT_VERSION);
    Path outputRoot = argPath(args, ARG_OUTPUT_DIR).orElse(DEFAULT_OUTPUT_ROOT);
    boolean overwrite = argBoolean(args, ARG_OVERWRITE, DEF_OVERWRITE);

    Path projectDir = outputRoot.resolve(artifact);

    if (Files.exists(projectDir)) {
      if (overwrite) {
        log.info(
            "♻️ Existing directory found. Deleting before regeneration: {}",
            projectDir.toAbsolutePath());
        deleteRecursively(projectDir);
      } else {
        throw new IllegalStateException(
            "Target directory already exists: "
                + projectDir.toAbsolutePath()
                + " (use --overwrite=true to replace it)");
      }
    }

    var depWeb =
        new Dependency.DependencyBuilder()
            .groupId("org.springframework.boot")
            .artifactId("spring-boot-starter-web")
            .build();

    var depTest =
        new Dependency.DependencyBuilder()
            .groupId("org.springframework.boot")
            .artifactId("spring-boot-starter-test")
            .scope("test")
            .build();

    var metadata =
        new SpringBootJavaProjectMetadataBuilder()
            .springBootVersion(bootVer)
            .javaVersion(javaVer)
            .groupId(groupId)
            .artifactId(artifact)
            .name(name)
            .description(DEF_DESCRIPTION)
            .packageName(pkg)
            .projectLocation(outputRoot)
            .dependencies(List.of(depWeb, depTest))
            .build();

    var type = new ProjectType(Framework.SPRING_BOOT, BuildTool.MAVEN, Language.JAVA);

    Path zip = service.generateProject(type, metadata);

    log.info("✅ Project archive generated at: {}", zip.toAbsolutePath());
    if (outputRoot.equals(DEFAULT_OUTPUT_ROOT)) {
      log.info("ℹ️  Tip: Use --{}=/absolute/path to control the output location.", ARG_OUTPUT_DIR);
    }
  }

  private String argOrDefault(ApplicationArguments args, String name, String def) {
    var values = args.getOptionValues(name);
    return (values != null && !values.isEmpty()) ? values.getFirst() : def;
  }

  private Optional<Path> argPath(ApplicationArguments args, String name) {
    var values = args.getOptionValues(name);
    if (values == null || values.isEmpty()) return Optional.empty();
    String raw = values.getFirst();
    if (raw == null || raw.isBlank()) return Optional.empty();
    return Optional.of(Paths.get(raw));
  }

  private boolean argBoolean(ApplicationArguments args, String name, boolean def) {
    var values = args.getOptionValues(name);
    if (values == null || values.isEmpty()) return def;
    String raw = values.getFirst();
    if (raw == null) return def;
    return switch (raw.trim().toLowerCase()) {
      case "true", "1", "yes", "y" -> true;
      case "false", "0", "no", "n" -> false;
      default -> def;
    };
  }

  private void deleteRecursively(Path dir) {
    if (!Files.exists(dir)) return;

    try (Stream<Path> paths = Files.walk(dir)) {
      paths
          .sorted(Comparator.reverseOrder())
          .forEach(
              p -> {
                try {
                  Files.deleteIfExists(p);
                } catch (IOException e) {
                  throw new UncheckedIOException(e);
                }
              });
    } catch (IOException e) {
      throw new UncheckedIOException("Failed to clean directory: " + dir.toAbsolutePath(), e);
    }
  }
}
